name: PR Label Guard

on:
  pull_request:
    types: [opened, reopened, labeled, unlabeled, edited, synchronize]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  check-labels:
    name: Validate Required Labels
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ·ï¸ Check Required Labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { context, github } = require('@actions/github');
            
            // Get PR labels
            const pr = context.payload.pull_request;
            const labels = pr.labels.map(label => label.name);
            
            console.log('ğŸ” Found labels:', labels);
            
            // Required label categories
            const requiredCategories = {
              'category': ['category:feature', 'category:bug', 'category:docs', 'category:maintenance', 'category:security', 'category:performance'],
              'priority': ['priority:P0', 'priority:P1', 'priority:P2', 'priority:P3']
            };
            
            const missingCategories = [];
            const violations = [];
            
            // Check each required category
            for (const [category, validLabels] of Object.entries(requiredCategories)) {
              const hasLabel = labels.some(label => validLabels.includes(label));
              if (!hasLabel) {
                missingCategories.push(category);
                violations.push(`Missing ${category} label. Must have one of: ${validLabels.join(', ')}`);
              }
            }
            
            // Check for multiple labels in same category
            for (const [category, validLabels] of Object.entries(requiredCategories)) {
              const matchingLabels = labels.filter(label => validLabels.includes(label));
              if (matchingLabels.length > 1) {
                violations.push(`Multiple ${category} labels found: ${matchingLabels.join(', ')}. Only one per category allowed.`);
              }
            }
            
            // Create status message
            let statusMessage = '';
            let status = 'success';
            
            if (violations.length > 0) {
              status = 'failure';
              statusMessage = `âŒ **ERIFYâ„¢ Label Requirements Not Met**\n\n${violations.map(v => `â€¢ ${v}`).join('\n')}\n\nğŸ“‹ **Required Labels:**\nâ€¢ **Category** (exactly one): ${requiredCategories.category.join(', ')}\nâ€¢ **Priority** (exactly one): ${requiredCategories.priority.join(', ')}\n\nğŸ“– See [labels documentation](./docs/labels.md) for details.`;
            } else {
              statusMessage = 'âœ… **All ERIFYâ„¢ label requirements met!**\n\nThis PR has the required category and priority labels.';
            }
            
            // Find existing label guard comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });
            
            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ERIFYâ„¢ Label Requirements')
            );
            
            // Update or create comment
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: statusMessage
              });
            } else if (status === 'failure') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: statusMessage
              });
            }
            
            // Set status check
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: pr.head.sha,
              state: status,
              context: 'ERIFYâ„¢ Label Guard',
              description: status === 'success' ? 'Required labels present' : `Missing: ${missingCategories.join(', ')}`
            });
            
            // Fail the job if labels are missing
            if (status === 'failure') {
              core.setFailed(`Missing required labels: ${missingCategories.join(', ')}`);
            }

  label-suggestions:
    name: Label Suggestions
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ¤– Suggest Labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { context } = require('@actions/github');
            const pr = context.payload.pull_request;
            
            // Analyze PR content for label suggestions
            const title = pr.title.toLowerCase();
            const body = (pr.body || '').toLowerCase();
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });
            
            const changedFiles = files.data.map(f => f.filename);
            
            // Category suggestions based on content analysis
            const categorySuggestions = [];
            
            if (title.includes('fix') || title.includes('bug') || body.includes('fixes')) {
              categorySuggestions.push('category:bug');
            }
            
            if (title.includes('feat') || title.includes('add') || body.includes('new feature')) {
              categorySuggestions.push('category:feature');
            }
            
            if (changedFiles.some(f => f.includes('README') || f.includes('.md'))) {
              categorySuggestions.push('category:docs');
            }
            
            if (title.includes('security') || body.includes('security') || body.includes('vulnerability')) {
              categorySuggestions.push('category:security');
            }
            
            if (title.includes('perf') || body.includes('performance') || body.includes('optimization')) {
              categorySuggestions.push('category:performance');
            }
            
            if (title.includes('chore') || title.includes('refactor') || title.includes('clean')) {
              categorySuggestions.push('category:maintenance');
            }
            
            // Priority suggestions based on keywords
            const prioritySuggestions = [];
            
            if (title.includes('critical') || body.includes('urgent') || body.includes('breaking')) {
              prioritySuggestions.push('priority:P0');
            } else if (title.includes('important') || body.includes('significant')) {
              prioritySuggestions.push('priority:P1');
            } else {
              prioritySuggestions.push('priority:P2');
            }
            
            // Create suggestion comment if we have suggestions
            if (categorySuggestions.length > 0 || prioritySuggestions.length > 0) {
              const suggestions = [
                'ğŸ¤– **ERIFYâ„¢ Label Suggestions**',
                '',
                'Based on the PR content, here are suggested labels:',
                '',
                'ğŸ“‚ **Category suggestions:**',
                ...categorySuggestions.map(s => `â€¢ \`${s}\``),
                '',
                'ğŸ¯ **Priority suggestions:**',
                ...prioritySuggestions.map(s => `â€¢ \`${s}\``),
                '',
                'ğŸ’¡ **To apply labels:**',
                '1. Add labels manually in the right sidebar',
                '2. Or ask a maintainer to add them',
                '3. See [labels guide](./docs/labels.md) for more info',
                '',
                'âš ï¸ *This PR will be blocked until required labels are added.*'
              ].join('\n');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: suggestions
              });
            }